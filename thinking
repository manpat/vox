-> = has reference to
: = Derived from

Block OnInteract should recieve info about interacter
	Should enable synchronisation over network

ComputerBlock -> Computer
Computer -> ComputerBlock // to change tint/textures or some shit
Computer -> ComputerGUI
Computer -> vm state and port states


Need GUI helpers to make shit not terrible
	buttons n' stuff
	info about gui things
	centralised way to get focus

ComputerGUI : Overlay

Computer : ThingWithPorts

ThingWithPortsManager {
	ThingWithPorts[] things;
}

ThingWithPorts {
	type // id into ThingsWithPortsRegistry

	PortIn[] inputs
	PortOut[] outputs
}

// How ports work kinda depends on what style language the computers will have

// Input ports can accept input from one source
// Output ports can output to many input ports

Port {
	enum Type {
		boolean, // Controlling lights n' shit; button input
		number, // Maybe split into int/float? Maybe not? Controlling thrusters
		string,

		composite/bus, // Bundles of data; port forwarders, connecting monitors/computers
		// Just pointer to thing? {Address/Port, Value} packets?
	}

	string name
}

PortIn : Port {
	Connection to PortOut

	Value GetValue() // pull value from connection or use default (sticky?)
}

PortOut : Port {
	Connection to PortIn []

	void SetValue(Value)
}


Possible things that can have ports
===================================

Computers
Memory/Storage/Disk Drives - I don't know why yet
Monitors
Pilot chair
Holo stuff

Lights
Buttons
Doors/Airlocks

Scanners
	Radar kinda
Motion sensors

Reactors
Power storage

Thrusters
"Beam me up scotty"
"Punch it chewie"
Shield generator
Weapon stuff





Moving things
=============

VoxelChunks can be at weird angles and can move so we need
a way to render and apply phyics to things near them

Biggest priority being ships

"Gravity Generator"

On collide with VoxelChunk set players gravity thing/parent
Rendering should be fine

Physics tho
	Making players move with ships could be awkward

	One possibility:
		simulate players in influence of ship as if it weren't moving and upright
		then simulate the ship as normal

		Separate physics world?
		Or copy rigidbodies to upright version and make real versions kinematic
			Update position/rotation as appropriate

	Another:
		Some way to parent rigidbodies?
		Constraints?



Networking
==========

Transport layer
---------------
	Lowest level
	Handles low level connections and sending/receiving packets
	Common between server and client

Replication layer
-----------------
	Synchronises entities between server and clients
	Gathers data from local player and manages updating of NetworkedPlayers

	VoxelChunk keeps track of modified blocks in buffer which is sent to transport 
		layer at end of frame

		Transport layer can then optimise packets for large changes


Where does physics simulation happen?
	On both server and client
	client phys is approximant for non local objects
	local player is responsible for own physics

	Physics on non player objects owned by server
		and approximated/updated by/on clients

What happens when a player interacts with a block?
	block::OnClientInteract -> *network* -> block::OnServerInteract
	ClientInteract shows gui which displays current state of block
		gui sends further messages to server
	ServerInteract does any actual logic

Should dynamics have both a Client side and Server side representation?
	Server doesn't need to know about text meshes
	Client doesn't necessarily need to know the state/logic of all locks

Client
------
	All mesh related stuff
	All rendering related stuff
	All gui stuff?
	LocalPlayer
		Responsible for own simulation
	NetworkedPlayer
	Local physics

Shared
------
	Neighborhood stuff
	Chunk stuff
		Both server and client need representations of chunks and neighborhoods
	Block definitions
		Client needs to know how to render, server needs to know what to update
	PlayerBase

	Physics simulation

Server
------
	ServerPlayer
	Client approximation ?
	Physics of non player objects

	Block update
